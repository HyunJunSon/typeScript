import { Match } from 'ts-toolbelt/out/Any/_Internal';
import { UnionOf } from 'ts-toolbelt/out/Object/UnionOf';
import { Next } from 'ts-toolbelt/out/Iteration/Next';
import { Prev } from 'ts-toolbelt/out/Iteration/Prev';
import { Iteration } from 'ts-toolbelt/out/Iteration/Iteration';
import { IterationOf } from 'ts-toolbelt/out/Iteration/IterationOf';
import { Is } from 'ts-toolbelt/out/Any/Is';
import { Boolean } from 'ts-toolbelt/out/Boolean/_Internal';
import { Cast } from 'ts-toolbelt/out/Any/Cast';
import { Pos } from 'ts-toolbelt/out/Iteration/Pos';
/**
 * @hidden
 */
declare type _IncludesDeep<O, M extends any, match extends Match, limit extends number, I extends Iteration = IterationOf<0>> = {
    0: _IncludesDeep<O extends object ? UnionOf<O> : O, M, match, limit, Next<I>>;
    1: 1;
    2: 0;
}[Pos<Prev<I>> extends limit ? 2 : Is<O, M, match>];
/**
 * Check whether `O`, or its sub-objects have fields that match `M`
 * where the maximum allowed depth is set with `limit`.
 *
 * @param O to be inspected
 * @param M to check field type
 * @param match (?=`'default'`) to change precision
 * @param limit (?=`'10'`) to change the check depth
 * @returns [[Boolean]]
 * @example
 * ```ts
 * ```
 * @author millsp, ctrlplusb
 */
export declare type IncludesDeep<O extends object, M extends any, match extends Match = 'default', limit extends number = 10> = _IncludesDeep<O, M, match, limit> extends infer X ? Cast<X, Boolean> : never;
export {};
