import { IterationOf } from 'ts-toolbelt/out/Iteration/IterationOf';
import { Iteration } from 'ts-toolbelt/out/Iteration/Iteration';
import { Next } from 'ts-toolbelt/out/Iteration/Next';
import { Length } from 'ts-toolbelt/out/List/Length';
import { Pos } from 'ts-toolbelt/out/Iteration/Pos';
import { Cast } from 'ts-toolbelt/out/Any/Cast';
import { List } from 'ts-toolbelt/out/List/List';
import { Naked } from 'ts-toolbelt/out/List/_Internal';
import { Extends } from 'ts-toolbelt/out/Any/Extends';
import { Append } from 'ts-toolbelt/out/List/Append';
/**
 * @hidden
 */
declare type __Zip<L extends List, L1 extends List, LN extends List = [], I extends Iteration = IterationOf<0>> = {
    0: __Zip<L, L1, Append<LN, [L[Pos<I>], L1[Pos<I>]]>, Next<I>>;
    1: LN;
}[Extends<Pos<I>, Length<L>>];
/**
 * @hidden
 */
export declare type _Zip<L extends List, L1 extends List> = __Zip<Naked<L>, L1> extends infer X ? Cast<X, List> : never;
/**
 * Pair up the entries of `L` with `L1`
 * @param L to pair up
 * @param L1 to pair up with
 * @returns [[List]]
 * @example
 * ```ts
 * ```
 */
export declare type Zip<L extends List, L1 extends List> = L extends unknown ? L1 extends unknown ? _Zip<L, L1> : never : never;
export {};
