import { Length } from 'ts-toolbelt/out/List/Length';
import { Pos } from 'ts-toolbelt/out/Iteration/Pos';
import { Next } from 'ts-toolbelt/out/Iteration/Next';
import { IterationOf } from 'ts-toolbelt/out/Iteration/IterationOf';
import { Iteration } from 'ts-toolbelt/out/Iteration/Iteration';
import { Cast } from 'ts-toolbelt/out/Any/Cast';
import { Record } from 'ts-toolbelt/out/Object/Record';
import { Key } from 'ts-toolbelt/out/Any/Key';
import { List } from 'ts-toolbelt/out/List/List';
import { Naked } from 'ts-toolbelt/out/List/_Internal';
import { Extends } from 'ts-toolbelt/out/Any/Extends';
import { PatchFlat } from 'ts-toolbelt/out/Object/Patch';
/**
 * @hidden
 */
declare type __ZipObj<LKeys extends List<Key>, LFields extends List, O extends object = {}, I extends Iteration = IterationOf<0>> = {
    0: __ZipObj<LKeys, LFields, PatchFlat<O, Record<LKeys[Pos<I>], LFields[Pos<I>]>>, Next<I>>;
    1: O;
}[Extends<Pos<I>, Length<LKeys>>];
/**
 * @hidden
 */
export declare type _ZipObj<LKeys extends List<Key>, LFields extends List> = __ZipObj<Naked<LKeys>, LFields> extends infer X ? Cast<X, object> : never;
/**
 * Create an [[Object]] from [[List]]s of keys & fields
 * @param LKeys its keys
 * @param LFields its fields
 * @returns [[Object]]
 * @example
 * ```ts
 * ```
 */
export declare type ZipObj<LKeys extends List<Key>, LFields extends List> = LKeys extends unknown ? LFields extends unknown ? _ZipObj<LKeys, LFields> : never : never;
export {};
