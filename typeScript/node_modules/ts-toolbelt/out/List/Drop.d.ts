import { Tail } from 'ts-toolbelt/out/List/Tail';
import { Cast } from 'ts-toolbelt/out/Any/Cast';
import { IterationOf } from 'ts-toolbelt/out/Iteration/IterationOf';
import { Iteration } from 'ts-toolbelt/out/Iteration/Iteration';
import { Way } from 'ts-toolbelt/out/Iteration/_Internal';
import { List } from 'ts-toolbelt/out/List/List';
import { Pos } from 'ts-toolbelt/out/Iteration/Pos';
import { Prev } from 'ts-toolbelt/out/Iteration/Prev';
import { Prepend } from 'ts-toolbelt/out/List/Prepend';
import { Naked } from 'ts-toolbelt/out/List/_Internal';
import { Extends } from 'ts-toolbelt/out/Any/Extends';
/**
 * @hidden
 */
declare type DropForth<L extends List, N extends Iteration> = {
    0: DropForth<Tail<L>, Prev<N>>;
    1: L;
}[Extends<0, Pos<N>>];
/**
 * @hidden
 */
declare type DropBack<L extends List, N extends Iteration, I extends Iteration = Prev<N>, LN extends List = []> = {
    0: DropBack<L, N, Prev<I>, Prepend<LN, L[Pos<I>]>>;
    1: LN;
}[Extends<-1, Pos<I>>];
/**
 * @hidden
 */
declare type __Drop<L extends List, N extends Iteration, way extends Way> = {
    '->': DropForth<L, N>;
    '<-': DropBack<L, N>;
}[way];
/**
 * @hidden
 */
export declare type _Drop<L extends List, N extends number, way extends Way = '->'> = __Drop<Naked<L>, IterationOf<N>, way> extends infer X ? Cast<X, List> : never;
/**
 * Remove `N` entries out of `L`
 * @param L to remove from
 * @param N to remove out
 * @param way (?=`'->'`) from front: '->', from end: '<-'
 * @returns [[List]]
 * @example
 * ```ts
 * ```
 */
export declare type Drop<L extends List, N extends number, way extends Way = '->'> = L extends unknown ? N extends unknown ? _Drop<L, N, way> : never : never;
export {};
