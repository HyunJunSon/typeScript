import { Cast } from 'ts-toolbelt/out/Any/Cast';
import { List } from 'ts-toolbelt/out/List/List';
import { Extends } from 'ts-toolbelt/out/Any/Extends';
import { Select } from 'ts-toolbelt/out/Union/Select';
import { Exclude } from 'ts-toolbelt/out/Union/Exclude';
import { Iteration } from 'ts-toolbelt/out/Iteration/Iteration';
import { IterationOf } from 'ts-toolbelt/out/Iteration/IterationOf';
import { Pos } from 'ts-toolbelt/out/Iteration/Pos';
import { Key } from 'ts-toolbelt/out/Iteration/Key';
import { Append } from 'ts-toolbelt/out/List/Append';
import { Next } from 'ts-toolbelt/out/Iteration/Next';
/**
 * @hidden
 */
declare type AppendExists<O extends object, LN extends List, I extends Iteration> = Key<I> extends keyof O ? Append<LN, O[Key<I>]> : Pos<I> extends keyof O ? Append<LN, O[Pos<I>]> : LN;
/**
 * @hidden
 */
declare type ___ListOf<O extends object, K, LN extends List = [], I extends Iteration = IterationOf<0>> = {
    0: ___ListOf<O, Exclude<K, Key<I>>, AppendExists<O, LN, I>, Next<I>>;
    1: LN;
}[Extends<[K], [never]>];
/**
 * @hidden
 */
declare type __ListOf<O extends object> = number extends keyof O ? O[number][] : string extends keyof O ? O[string][] : symbol extends keyof O ? O[symbol][] : ___ListOf<O, Select<keyof O, number | `${number}`>>;
/**
 * @hidden
 */
export declare type _ListOf<O extends object> = __ListOf<O> extends infer X ? Cast<X, List> : never;
/**
 * Transform an [[Object]] into a [[List]]
 * (It will only pick numeric literal indexes)
 * @param O to transform
 * @returns [[List]]
 * @example
 * ```ts
 * ```
 */
export declare type ListOf<O extends object> = O extends unknown ? _ListOf<O> : never;
export {};
