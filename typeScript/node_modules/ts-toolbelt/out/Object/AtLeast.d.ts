import { _Pick } from 'ts-toolbelt/out/Object/Pick';
import { Key } from 'ts-toolbelt/out/Any/Key';
import { Keys } from 'ts-toolbelt/out/Any/Keys';
import { RequiredFlat } from 'ts-toolbelt/out/Object/Required';
import { Extends } from 'ts-toolbelt/out/Any/Extends';
import { ComputeRaw } from 'ts-toolbelt/out/Any/Compute';
import { OptionalFlat } from 'ts-toolbelt/out/Object/Optional';
/**
 * @hidden
 */
declare type RequiredIfKeys<O extends object, K extends Key> = Extends<keyof O & K, K> extends 1 ? RequiredFlat<O> : O;
/**
 * @hidden
 */
declare type __AtLeast<O extends object, K extends Key> = K extends keyof O ? _Pick<O, K> & OptionalFlat<O> : O;
/**
 * @hidden
 */
declare type _AtLeast<O extends object, K extends Key> = ComputeRaw<__AtLeast<RequiredIfKeys<O, K>, K>>;
/**
 * Make that at least one of the keys `K` are required in `O` at a time.
 * @param O to make required
 * @param K (?=`keyof O`) to choose fields
 * @returns [[Object]] [[Union]]
 * @example
 * ```ts
 * ```
 */
export declare type AtLeast<O extends object, K extends Key = Keys<O>> = O extends unknown ? _AtLeast<O, K> : never;
export {};
